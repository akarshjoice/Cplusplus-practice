import tkinter as tk
from tkinter import ttk, messagebox
import socket
import threading
import queue

class Session:
    def __init__(self, master, tab_name):
        self.master = master
        self.tab_name = tab_name
        self.frame = ttk.Frame(master)
        self.client_socket = None
        self.message_queue = queue.Queue()
        self.host = 'localhost'
        self.port = 5000
        self.connected = False
        
        # GUI components
        self.symbol_entry = None
        self.price_entry = None
        self.qty_entry = None
        self.ordertype_entry = None
        self.message_info_text = None
        self.order_tree = None
        self.order_transactions_list = None
        
        self.setup_ui()

    def setup_ui(self):
        # Main container
        main_frame = ttk.Frame(self.frame)
        main_frame.pack(fill='both', expand=True)

        # Left panel
        left_panel = ttk.Frame(main_frame)
        left_panel.pack(side='left', fill='both', expand=True)

        # Order Tree
        order_tree_frame = ttk.Labelframe(left_panel, text="Order Details")
        order_tree_frame.pack(fill='both', expand=True)

        self.order_tree = ttk.Treeview(order_tree_frame, columns=("clordid", "price", "quantity", "messagetype"), show="headings")
        self.order_tree.heading("clordid", text="ClOrdID")
        self.order_tree.heading("price", text="Price")
        self.order_tree.heading("quantity", text="Quantity")
        self.order_tree.heading("messagetype", text="MessageType")
        self.order_tree.pack(side='left', fill='both', expand=True)

        # Transactions List
        transactions_frame = ttk.Labelframe(left_panel, text="Order Transactions")
        transactions_frame.pack(fill='both', expand=True)

        self.order_transactions_list = tk.Listbox(transactions_frame)
        self.order_transactions_list.pack(fill='both', expand=True)

        # FIX Fields
        fields_frame = ttk.Labelframe(left_panel, text="FIX Fields")
        fields_frame.pack(fill='x')

        ttk.Label(fields_frame, text="Symbol:").grid(row=0, column=0, padx=5, pady=5)
        self.symbol_entry = ttk.Entry(fields_frame)
        self.symbol_entry.grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(fields_frame, text="Price:").grid(row=1, column=0, padx=5, pady=5)
        self.price_entry = ttk.Entry(fields_frame)
        self.price_entry.grid(row=1, column=1, padx=5, pady=5)

        ttk.Label(fields_frame, text="Qty:").grid(row=2, column=0, padx=5, pady=5)
        self.qty_entry = ttk.Entry(fields_frame)
        self.qty_entry.grid(row=2, column=1, padx=5, pady=5)

        ttk.Label(fields_frame, text="OrderType:").grid(row=3, column=0, padx=5, pady=5)
        self.ordertype_entry = ttk.Entry(fields_frame)
        self.ordertype_entry.grid(row=3, column=1, padx=5, pady=5)

        # Right panel
        right_panel = ttk.Frame(main_frame)
        right_panel.pack(side='right', fill='both', expand=True)

        # Message Info
        message_frame = ttk.Labelframe(right_panel, text="Message Info")
        message_frame.pack(fill='both', expand=True)

        self.message_info_text = tk.Text(message_frame, wrap='word')
        self.message_info_text.pack(fill='both', expand=True)

class FixClientSimulator(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("FIX Client Simulator")
        self.sessions = []
        self.current_session = None
        
        self.setup_menu()
        self.setup_notebook()
        self.add_session()
        self.process_queue()

    def setup_menu(self):
        menubar = tk.Menu(self)
        self.config(menu=menubar)

        connection_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Session", menu=connection_menu)
        connection_menu.add_command(label="New Session", command=self.add_session)
        connection_menu.add_command(label="Connect", command=self.show_connection_dialog)

    def setup_notebook(self):
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill='both', expand=True)
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)

    def add_session(self):
        session_num = len(self.sessions) + 1
        session = Session(self.notebook, f"Session {session_num}")
        self.sessions.append(session)
        self.notebook.add(session.frame, text=session.tab_name)
        self.notebook.select(session.frame)

    def get_current_session(self):
        current_tab = self.notebook.select()
        if current_tab:
            return next(s for s in self.sessions if s.frame.winfo_id() == int(current_tab.split('.')[-1]))
        return None

    def on_tab_changed(self, event):
        self.current_session = self.get_current_session()

    def show_connection_dialog(self):
        session = self.get_current_session()
        dialog = tk.Toplevel(self)
        dialog.title("Connect to Server")

        ttk.Label(dialog, text="Server IP:").grid(row=0, column=0, padx=5, pady=5)
        ip_entry = ttk.Entry(dialog)
        ip_entry.insert(0, session.host)
        ip_entry.grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(dialog, text="Port:").grid(row=1, column=0, padx=5, pady=5)
        port_entry = ttk.Entry(dialog)
        port_entry.insert(0, str(session.port))
        port_entry.grid(row=1, column=1, padx=5, pady=5)

        def connect():
            session.host = ip_entry.get()
            session.port = int(port_entry.get())
            self.connect_to_server(session)
            dialog.destroy()

        ttk.Button(dialog, text="Connect", command=connect).grid(row=2, columnspan=2, pady=10)

    def connect_to_server(self, session):
        try:
            session.client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            session.client_socket.connect((session.host, session.port))
            session.connected = True
            threading.Thread(target=lambda: self.receive_messages(session), daemon=True).start()
        except Exception as e:
            messagebox.showerror("Connection Error", f"Could not connect: {e}")

    def send_message(self):
        session = self.get_current_session()
        if not session or not session.connected:
            return

        msg = f"Symbol={session.symbol_entry.get()};Price={session.price_entry.get()};" \
              f"Qty={session.qty_entry.get()};OrderType={session.ordertype_entry.get()}"
        
        try:
            session.client_socket.sendall(msg.encode())
            session.symbol_entry.delete(0, tk.END)
            session.price_entry.delete(0, tk.END)
            session.qty_entry.delete(0, tk.END)
            session.ordertype_entry.delete(0, tk.END)
        except Exception as e:
            messagebox.showerror("Send Error", f"Failed to send message: {e}")

    def receive_messages(self, session):
        while session.connected:
            try:
                data = session.client_socket.recv(1024).decode()
                if data:
                    session.message_queue.put(data)
                else:
                    break
            except Exception as e:
                print(f"Receive error: {e}")
                session.connected = False
                break

    def process_queue(self):
        for session in self.sessions:
            while not session.message_queue.empty():
                msg = session.message_queue.get()
                session.message_info_text.insert(tk.END, msg + "\n")
                session.message_info_text.see(tk.END)
        self.after(100, self.process_queue)

if __name__ == "__main__":
    app = FixClientSimulator()
    app.mainloop()
