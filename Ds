import tkinter as tk
from tkinter import ttk, messagebox
import socket
import threading
import queue

class Session:
    def __init__(self, name, host, port, log_callback):
        self.name = name
        self.host = host
        self.port = port
        self.socket = None
        self.message_queue = queue.Queue()
        self.receive_thread = None
        self.connected = False
        self.log_callback = log_callback  # This callback is now thread-safe

    def connect(self):
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.host, self.port))
            self.connected = True
            self.log_callback(self.name, f"Connected to {self.host}:{self.port}")
            self.receive_thread = threading.Thread(target=self.receive_messages, daemon=True)
            self.receive_thread.start()
        except Exception as e:
            self.log_callback(self.name, f"Error connecting: {e}")

    def send_message(self, message):
        if self.socket and self.connected:
            try:
                self.socket.sendall(message.encode())
                self.log_callback(self.name, f"Sent: {message}")
            except Exception as e:
                self.log_callback(self.name, f"Error sending message: {e}")

    def receive_messages(self):
        while self.connected:
            try:
                data = self.socket.recv(1024).decode()
                if data:
                    self.message_queue.put(data)
            except Exception as e:
                self.log_callback(self.name, f"Error receiving message: {e}")
                self.connected = False
                break

    def get_next_message(self):
        try:
            return self.message_queue.get_nowait()
        except queue.Empty:
            return None

class FixClientSimulator(tk.Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.master = master
        master.title("FIX Client Simulator")

        self.sessions = {}
        self.session_logs = {}

        self.setup_ui()
        self.setup_menu()

        self.master.after(500, self.process_active_session_messages)
        self.master.after(2000, self.process_all_session_messages)

    def setup_ui(self):
        self.grid(row=0, column=0, sticky="nsew")
        self.master.rowconfigure(0, weight=1)
        self.master.columnconfigure(0, weight=1)

        self.notebook = ttk.Notebook(self.master)
        self.notebook.grid(row=1, column=0, sticky="nsew")

    def setup_menu(self):
        menubar = tk.Menu(self.master)
        self.master.config(menu=menubar)

        connection_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Connection", menu=connection_menu)
        connection_menu.add_command(label="Add Session", command=self.show_add_session_dialog)

    def show_add_session_dialog(self):
        dialog = tk.Toplevel(self)
        dialog.title("Add Session")
        dialog.geometry("300x200")

        tk.Label(dialog, text="Session Name:").pack(pady=5)
        name_entry = ttk.Entry(dialog)
        name_entry.pack(pady=5)

        tk.Label(dialog, text="Server IP:").pack(pady=5)
        ip_entry = ttk.Entry(dialog)
        ip_entry.pack(pady=5)

        tk.Label(dialog, text="Port:").pack(pady=5)
        port_entry = ttk.Entry(dialog)
        port_entry.pack(pady=5)

        def add_session():
            name = name_entry.get().strip()
            ip = ip_entry.get().strip()
            port = port_entry.get().strip()

            if not name or not ip or not port.isdigit():
                messagebox.showerror("Error", "Invalid input")
                return

            port = int(port)
            if name in self.sessions:
                messagebox.showerror("Error", "Session already exists")
                return

            # Wrap log_callback to ensure it's executed in the main thread
            log_callback = lambda sn, msg: self.master.after(0, self.log_message, sn, msg)
            session = Session(name, ip, port, log_callback)
            session.connect()
            self.sessions[name] = session

            frame, log_widget = self.create_session_tab(name)
            self.notebook.add(frame, text=name)
            self.notebook.select(frame)
            self.session_logs[name] = log_widget

            dialog.destroy()

        ttk.Button(dialog, text="Add", command=add_session).pack(pady=10)

    def create_session_tab(self, session_name):
        frame = ttk.Frame(self.notebook)

        message_log_frame = ttk.Labelframe(frame, text="Message Log")
        message_log_frame.pack(fill="both", expand=True, padx=10, pady=5)
        message_log_text = tk.Text(message_log_frame, height=10, wrap="word", state="disabled")
        message_log_text.pack(fill="both", expand=True)

        return frame, message_log_text

    def log_message(self, session_name, message):
        if session_name in self.session_logs:
            log_widget = self.session_logs[session_name]
            log_widget.config(state="normal")
            log_widget.insert("end", message + "\n")
            log_widget.config(state="disabled")
            log_widget.yview("end")

    def get_active_session(self):
        selected_tab = self.notebook.select()
        return self.notebook.tab(selected_tab, "text") if selected_tab else None

    def process_active_session_messages(self):
        active_session_name = self.get_active_session()
        if active_session_name and active_session_name in self.sessions:
            session = self.sessions[active_session_name]
            while True:
                message = session.get_next_message()
                if not message:
                    break
                self.log_message(active_session_name, f"Received: {message}")

        self.master.after(500, self.process_active_session_messages)

    def process_all_session_messages(self):
        for session_name, session in self.sessions.items():
            if session_name != self.get_active_session():
                while True:
                    message = session.get_next_message()
                    if not message:
                        break
                    self.log_message(session_name, f"Received: {message}")

        self.master.after(2000, self.process_all_session_messages)

    def send_fix_message(self):
        session_name = self.get_active_session()
        if not session_name or session_name not in self.sessions:
            messagebox.showerror("Error", "No active session selected")
            return

        message = "Sample FIX Message"
        self.sessions[session_name].send_message(message)

if __name__ == "__main__":
    root = tk.Tk()
    app = FixClientSimulator(master=root)
    app.pack(fill="both", expand=True)
    root.mainloop()
